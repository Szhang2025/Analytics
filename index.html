<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSV Data Analysis Tool</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jstat@1.9.5/dist/jstat.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-gap: 20px;
        }
        
        .header {
            grid-column: 1 / -1;
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #4a6fa5;
        }
        
        .header h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .panel {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 20px;
        }
        
        .upload-panel {
            grid-column: 1;
        }
        
        .analysis-panel {
            grid-column: 2;
        }
        
        .results-panel {
            grid-column: 1 / -1;
            min-height: 500px;
        }
        
        h2 {
            color: #4a6fa5;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
        }
        
        .file-upload-area {
            border: 2px dashed #4a6fa5;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            margin-bottom: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .file-upload-area:hover {
            background-color: #f0f5ff;
        }
        
        .file-upload-area.dragover {
            background-color: #e6f0ff;
            border-color: #2c5aa0;
        }
        
        #fileInput {
            display: none;
        }
        
        .btn {
            background-color: #4a6fa5;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.3s;
            margin-right: 10px;
            margin-top: 10px;
        }
        
        .btn:hover {
            background-color: #3a5a80;
        }
        
        .btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        .btn-secondary {
            background-color: #6c757d;
        }
        
        .btn-secondary:hover {
            background-color: #5a6268;
        }
        
        .select-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }
        
        select, input[type="number"], input[type="text"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }
        
        .radio-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        
        .radio-option {
            display: flex;
            align-items: center;
            background: #f8f9fa;
            padding: 8px 12px;
            border-radius: 5px;
            border: 1px solid #dee2e6;
            cursor: pointer;
        }
        
        .radio-option:hover {
            background: #e9ecef;
        }
        
        .radio-option input {
            margin-right: 8px;
            cursor: pointer;
        }
        
        .radio-option label {
            margin: 0;
            cursor: pointer;
        }
        
        .data-preview-container {
            margin-top: 20px;
            overflow: hidden;
            position: relative;
        }
        
        .table-navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 5px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        
        .table-nav-btn {
            background: #4a6fa5;
            color: white;
            border: none;
            padding: 5px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .table-nav-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .preview-table-wrapper {
            overflow-x: auto;
            max-height: 300px;
            border: 1px solid #ddd;
            border-radius: 5px;
            position: relative;
        }
        
        .preview-table {
            width: 100%;
            border-collapse: collapse;
            min-width: 600px;
        }
        
        .preview-table th, .preview-table td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
            min-width: 120px;
        }
        
        .preview-table th {
            background-color: #4a6fa5;
            color: white;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .preview-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        .preview-table tr:hover {
            background-color: #f0f5ff;
        }
        
        .chart-container {
            position: relative;
            height: 400px;
            width: 100%;
            margin-top: 20px;
        }
        
        #chartCanvas {
            width: 100% !important;
            height: 100% !important;
        }
        
        .statistics-output {
            background-color: #f8f9fa;
            border-radius: 5px;
            padding: 20px;
            margin-top: 20px;
            font-family: 'Consolas', 'Monaco', monospace;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .stat-header {
            color: #4a6fa5;
            font-weight: bold;
            margin: 15px 0 5px 0;
            border-bottom: 2px solid #4a6fa5;
            padding-bottom: 3px;
        }
        
        .stat-item {
            margin: 5px 0;
        }
        
        .stat-value {
            color: #2c3e50;
            font-weight: 600;
        }
        
        /* Help Popup */
        .help-popup {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 350px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            overflow: hidden;
            display: none;
        }
        
        .help-popup.active {
            display: block;
        }
        
        .help-header {
            background-color: #4a6fa5;
            color: white;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .help-header h3 {
            margin: 0;
        }
        
        .close-help {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            line-height: 1;
        }
        
        .help-content {
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .help-page {
            display: none;
        }
        
        .help-page.active {
            display: block;
        }
        
        .help-page h4 {
            color: #4a6fa5;
            margin-bottom: 10px;
        }
        
        .help-navigation {
            display: flex;
            justify-content: space-between;
            padding: 15px;
            border-top: 1px solid #eee;
        }
        
        .page-indicator {
            font-weight: 600;
            color: #666;
        }
        
        .help-btn {
            background-color: #f0f5ff;
            border: 1px solid #4a6fa5;
            color: #4a6fa5;
            padding: 5px 15px;
            border-radius: 5px;
            cursor: pointer;
        }
        
        .help-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .toggle-help {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: #4a6fa5;
            color: white;
            border: none;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 999;
        }
        
        .toggle-help:hover {
            background-color: #3a5a80;
        }
        
        .error-message {
            color: #e74c3c;
            background-color: #fdeaea;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            display: none;
        }
        
        .error-message.active {
            display: block;
        }
        
        .test-params {
            background-color: #f0f5ff;
            border-radius: 5px;
            padding: 15px;
            margin-top: 10px;
            display: none;
        }
        
        .test-params.active {
            display: block;
        }
        
        .analysis-results {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 20px;
        }
        
        .analysis-chart {
            grid-column: 1;
        }
        
        .analysis-stats {
            grid-column: 2;
        }
        
        @media (max-width: 992px) {
            .container {
                grid-template-columns: 1fr;
            }
            
            .upload-panel, .analysis-panel {
                grid-column: 1;
            }
            
            .help-popup {
                width: 300px;
            }
            
            .analysis-results {
                grid-template-columns: 1fr;
            }
            
            .analysis-chart, .analysis-stats {
                grid-column: 1;
            }
        }
        
        .status-message {
            text-align: center;
            padding: 20px;
            color: #666;
            font-style: italic;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #4a6fa5;
            font-size: 18px;
        }
        
        .success-message {
            background-color: #d4edda;
            color: #155724;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            display: none;
        }
        
        .success-message.active {
            display: block;
        }
        
        .warning-message {
            background-color: #fff3cd;
            color: #856404;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            display: none;
        }
        
        .warning-message.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>CSV Data Analysis Tool</h1>
            <p>Upload your CSV file, select variables, and perform statistical analysis with visualizations</p>
        </div>
        
        <div class="panel upload-panel">
            <h2>1. Upload CSV File</h2>
            <div class="file-upload-area" id="dropArea">
                <div style="font-size: 48px;">ðŸ“Š</div>
                <p>Drag & drop your CSV file here or click to browse</p>
                <input type="file" id="fileInput" accept=".csv">
                <p><small>Maximum file size: 5MB</small></p>
            </div>
            <div class="error-message" id="uploadError"></div>
            
            <button class="btn btn-secondary" id="loadSampleBtn">Load Sample Data</button>
            
            <div id="dataPreview" style="display: none;">
                <h3>Data Preview</h3>
                <div class="data-preview-container">
                    <div class="table-navigation">
                        <button class="table-nav-btn" id="prevColBtn" disabled>â—€ Previous</button>
                        <span id="colRange">Columns 1-5</span>
                        <button class="table-nav-btn" id="nextColBtn">Next â–¶</button>
                    </div>
                    <div class="preview-table-wrapper">
                        <table class="preview-table" id="previewTable">
                            <!-- Data will be populated here -->
                        </table>
                    </div>
                </div>
                <p id="dataInfo" style="margin-top: 10px; font-style: italic;"></p>
                <div class="success-message" id="dataLoadedMessage">Data loaded successfully! Select variables below to analyze.</div>
            </div>
        </div>
        
        <div class="panel analysis-panel">
            <h2>2. Analysis Configuration</h2>
            <div class="select-group">
                <label for="var1">First Variable (X-axis/Group)</label>
                <select id="var1" disabled>
                    <option value="">Select a variable</option>
                </select>
            </div>
            
            <div class="select-group">
                <label for="var2">Second Variable (Y-axis/Optional)</label>
                <select id="var2" disabled>
                    <option value="">Select a variable (optional)</option>
                </select>
            </div>
            
            <div class="select-group">
                <label>Analysis Type</label>
                <div class="radio-group" id="analysisTypeGroup">
                    <div class="status-message">Select variables to see analysis options</div>
                </div>
            </div>
            
            <div class="test-params" id="testParams">
                <h4>Test Parameters</h4>
                <div id="proportionTestParams" style="display: none;">
                    <label for="expectedProportions">Expected Proportions (comma-separated, sum to 1)</label>
                    <input type="text" id="expectedProportions" placeholder="0.25,0.25,0.25,0.25">
                    <small style="color: #666;">Leave empty for equal proportions</small>
                </div>
                <div id="tTestParams" style="display: none;">
                    <label for="testValue">Test Value (Î¼â‚€)</label>
                    <input type="number" id="testValue" step="0.01" value="0">
                </div>
                <div id="propCIParams" style="display: none;">
                    <label for="confidenceLevel">Confidence Level (%)</label>
                    <input type="number" id="confidenceLevel" min="80" max="99" value="95" step="1">
                </div>
                <div id="targetCategoryParams" style="display: none;">
                    <label for="targetCategory">Target Category for CI</label>
                    <select id="targetCategory">
                        <!-- Will be populated dynamically -->
                    </select>
                </div>
            </div>
            
            <div class="warning-message" id="anovaWarning" style="display: none;">
                <strong>Note:</strong> The categorical variable has more than 2 categories. ANOVA will be performed instead of t-test.
            </div>
            
            <button id="analyzeBtn" class="btn" disabled>Run Analysis</button>
            <button id="resetBtn" class="btn btn-secondary">Reset All</button>
        </div>
        
        <div class="panel results-panel">
            <h2>3. Analysis Results</h2>
            <div id="resultsContainer">
                <div class="status-message">
                    Configure and run an analysis to see results here.
                </div>
            </div>
        </div>
    </div>
    
    <!-- Help Button -->
    <button class="toggle-help" id="toggleHelp">?</button>
    
    <!-- Help Popup -->
    <div class="help-popup" id="helpPopup">
        <div class="help-header">
            <h3>Analysis Guide</h3>
            <button class="close-help" id="closeHelp">&times;</button>
        </div>
        <div class="help-content">
            <div class="help-page active" id="page1">
                <h4>Single Categorical Variable</h4>
                <p><strong>Bar Plot:</strong> Shows frequency distribution of categories.</p>
                <p><strong>Test of Proportion:</strong> Chi-square goodness-of-fit test comparing observed to expected proportions.</p>
                <p><strong>Confidence Interval:</strong> Calculates CI for proportion of a specific category.</p>
            </div>
            
            <div class="help-page" id="page2">
                <h4>Single Continuous Variable</h4>
                <p><strong>Histogram:</strong> Displays distribution with frequency bins.</p>
                <p><strong>Box Plot:</strong> Shows median, quartiles, and potential outliers.</p>
                <p><strong>Confidence Interval:</strong> Calculates CI for the mean.</p>
                <p><strong>T-test:</strong> One-sample t-test against specified value.</p>
            </div>
            
            <div class="help-page" id="page3">
                <h4>Two Variables Analysis</h4>
                <p><strong>Scatter Plot:</strong> For two continuous variables, shows relationship.</p>
                <p><strong>Grouped Bar Plot:</strong> For categorical vs categorical, shows cross-tabulation.</p>
                <p><strong>Box Plot by Group:</strong> For categorical vs continuous, compares distributions.</p>
                <p><strong>T-test/ANOVA:</strong> For categorical vs continuous: T-test (2 groups) or ANOVA (>2 groups).</p>
                <p><strong>Chi-square Test:</strong> Tests association between categorical variables.</p>
            </div>
        </div>
        <div class="help-navigation">
            <button class="help-btn" id="prevPage" disabled>Previous</button>
            <span class="page-indicator">Page <span id="currentPage">1</span> of 3</span>
            <button class="help-btn" id="nextPage">Next</button>
        </div>
    </div>

    <script>
        // Global variables
        let csvData = [];
        let headers = [];
        let columnTypes = {};
        let currentHelpPage = 1;
        let currentChart = null;
        let currentColStart = 0;
        const visibleCols = 5;
        
        // DOM elements
        const fileInput = document.getElementById('fileInput');
        const dropArea = document.getElementById('dropArea');
        const uploadError = document.getElementById('uploadError');
        const dataPreview = document.getElementById('dataPreview');
        const previewTable = document.getElementById('previewTable');
        const dataInfo = document.getElementById('dataInfo');
        const dataLoadedMessage = document.getElementById('dataLoadedMessage');
        const var1Select = document.getElementById('var1');
        const var2Select = document.getElementById('var2');
        const analysisTypeGroup = document.getElementById('analysisTypeGroup');
        const testParams = document.getElementById('testParams');
        const proportionTestParams = document.getElementById('proportionTestParams');
        const tTestParams = document.getElementById('tTestParams');
        const propCIParams = document.getElementById('propCIParams');
        const targetCategoryParams = document.getElementById('targetCategoryParams');
        const targetCategorySelect = document.getElementById('targetCategory');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const resetBtn = document.getElementById('resetBtn');
        const loadSampleBtn = document.getElementById('loadSampleBtn');
        const resultsContainer = document.getElementById('resultsContainer');
        const toggleHelp = document.getElementById('toggleHelp');
        const helpPopup = document.getElementById('helpPopup');
        const closeHelp = document.getElementById('closeHelp');
        const prevPageBtn = document.getElementById('prevPage');
        const nextPageBtn = document.getElementById('nextPage');
        const currentPageSpan = document.getElementById('currentPage');
        const prevColBtn = document.getElementById('prevColBtn');
        const nextColBtn = document.getElementById('nextColBtn');
        const colRangeSpan = document.getElementById('colRange');
        const anovaWarning = document.getElementById('anovaWarning');
        
        // Event Listeners
        document.addEventListener('DOMContentLoaded', function() {
            // File upload events
            dropArea.addEventListener('click', () => fileInput.click());
            dropArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropArea.classList.add('dragover');
            });
            dropArea.addEventListener('dragleave', () => {
                dropArea.classList.remove('dragover');
            });
            dropArea.addEventListener('drop', (e) => {
                e.preventDefault();
                dropArea.classList.remove('dragover');
                if (e.dataTransfer.files.length) {
                    fileInput.files = e.dataTransfer.files;
                    handleFileUpload(e.dataTransfer.files[0]);
                }
            });
            
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length) {
                    handleFileUpload(e.target.files[0]);
                }
            });
            
            loadSampleBtn.addEventListener('click', loadSampleData);
            
            // Variable selection events
            var1Select.addEventListener('change', function() {
                updateAnalysisOptions();
            });
            
            var2Select.addEventListener('change', function() {
                updateAnalysisOptions();
            });
            
            // Table navigation
            prevColBtn.addEventListener('click', function() {
                navigateColumns(-visibleCols);
            });
            
            nextColBtn.addEventListener('click', function() {
                navigateColumns(visibleCols);
            });
            
            // Analysis button
            analyzeBtn.addEventListener('click', runAnalysis);
            
            // Reset button
            resetBtn.addEventListener('click', resetApp);
            
            // Help popup events
            toggleHelp.addEventListener('click', toggleHelpPopup);
            closeHelp.addEventListener('click', toggleHelpPopup);
            prevPageBtn.addEventListener('click', () => changeHelpPage(-1));
            nextPageBtn.addEventListener('click', () => changeHelpPage(1));
            
            // Load initial sample data
            loadSampleData();
        });
        
        // Statistical Functions
        function mean(data) {
            if (data.length === 0) return NaN;
            const sum = data.reduce((a, b) => a + b, 0);
            return sum / data.length;
        }
        
        function variance(data) {
            if (data.length <= 1) return NaN;
            const m = mean(data);
            const sumSquares = data.reduce((a, b) => a + Math.pow(b - m, 2), 0);
            return sumSquares / (data.length - 1);
        }
        
        function stdDev(data) {
            const v = variance(data);
            return isNaN(v) ? NaN : Math.sqrt(v);
        }
        
        function median(data) {
            if (data.length === 0) return NaN;
            const sorted = [...data].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
        }
        
        function quartiles(data) {
            if (data.length === 0) return { q1: NaN, q2: NaN, q3: NaN };
            const sorted = [...data].sort((a, b) => a - b);
            const q1 = sorted[Math.floor(sorted.length * 0.25)];
            const q2 = median(sorted);
            const q3 = sorted[Math.floor(sorted.length * 0.75)];
            return { q1, q2, q3 };
        }
        
        function correlation(x, y) {
            if (x.length !== y.length || x.length < 2) return NaN;
            const meanX = mean(x);
            const meanY = mean(y);
            
            let numerator = 0;
            let denomX = 0;
            let denomY = 0;
            
            for (let i = 0; i < x.length; i++) {
                numerator += (x[i] - meanX) * (y[i] - meanY);
                denomX += Math.pow(x[i] - meanX, 2);
                denomY += Math.pow(y[i] - meanY, 2);
            }
            
            if (denomX === 0 || denomY === 0) return NaN;
            return numerator / Math.sqrt(denomX * denomY);
        }
        
        function chiSquareGoodnessOfFit(observed, expected) {
            let chi2 = 0;
            for (let i = 0; i < observed.length; i++) {
                chi2 += Math.pow(observed[i] - expected[i], 2) / expected[i];
            }
            
            const df = observed.length - 1;
            const pValue = 1 - jStat.chisquare.cdf(chi2, df);
            
            return { chi2, df, pValue };
        }
        
        function chiSquareIndependence(contingencyTable) {
            const rows = contingencyTable.length;
            const cols = contingencyTable[0].length;
            
            // Calculate row and column totals
            const rowTotals = Array(rows).fill(0);
            const colTotals = Array(cols).fill(0);
            let grandTotal = 0;
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    rowTotals[i] += contingencyTable[i][j];
                    colTotals[j] += contingencyTable[i][j];
                    grandTotal += contingencyTable[i][j];
                }
            }
            
            // Calculate expected frequencies
            const expected = Array(rows).fill().map(() => Array(cols).fill(0));
            let chi2 = 0;
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    expected[i][j] = (rowTotals[i] * colTotals[j]) / grandTotal;
                    chi2 += Math.pow(contingencyTable[i][j] - expected[i][j], 2) / expected[i][j];
                }
            }
            
            const df = (rows - 1) * (cols - 1);
            const pValue = 1 - jStat.chisquare.cdf(chi2, df);
            
            return { chi2, df, pValue, expected };
        }
        
        function tTestOneSample(data, mu0) {
            const n = data.length;
            const sampleMean = mean(data);
            const sampleStd = stdDev(data);
            const stdError = sampleStd / Math.sqrt(n);
            const t = (sampleMean - mu0) / stdError;
            const df = n - 1;
            const pValue = 2 * (1 - jStat.studentt.cdf(Math.abs(t), df));
            
            return { t, df, pValue, sampleMean, stdError };
        }
        
        function tTestTwoSample(group1Data, group2Data, equalVar = true) {
            const n1 = group1Data.length;
            const n2 = group2Data.length;
            
            if (n1 < 2 || n2 < 2) {
                throw new Error('Each group must have at least 2 observations for t-test');
            }
            
            const mean1 = mean(group1Data);
            const mean2 = mean(group2Data);
            const var1 = variance(group1Data);
            const var2 = variance(group2Data);
            
            let t, df, pooledVar, stdError;
            
            if (equalVar) {
                // Equal variances assumed
                pooledVar = ((n1 - 1) * var1 + (n2 - 1) * var2) / (n1 + n2 - 2);
                stdError = Math.sqrt(pooledVar * (1/n1 + 1/n2));
                t = (mean1 - mean2) / stdError;
                df = n1 + n2 - 2;
            } else {
                // Welch's t-test (unequal variances)
                stdError = Math.sqrt(var1/n1 + var2/n2);
                t = (mean1 - mean2) / stdError;
                
                // Welch-Satterthwaite equation for degrees of freedom
                const dfNumerator = Math.pow(var1/n1 + var2/n2, 2);
                const dfDenominator = Math.pow(var1/n1, 2)/(n1-1) + Math.pow(var2/n2, 2)/(n2-1);
                df = dfNumerator / dfDenominator;
            }
            
            // Two-tailed p-value
            const pValue = 2 * (1 - jStat.studentt.cdf(Math.abs(t), df));
            
            return {
                t, df, pValue, 
                mean1, mean2, 
                var1, var2,
                n1, n2,
                stdError,
                meanDiff: mean1 - mean2,
                equalVar: equalVar
            };
        }
        
        function anovaOneWay(groupsData) {
            const k = groupsData.length; // number of groups
            let overallMean = 0;
            let totalN = 0;
            const groupStats = [];
            
            // Calculate group statistics
            for (let i = 0; i < k; i++) {
                const data = groupsData[i];
                const n = data.length;
                if (n === 0) continue;
                
                const groupMean = mean(data);
                const groupVar = variance(data);
                
                groupStats.push({
                    n: n,
                    mean: groupMean,
                    variance: groupVar,
                    sum: data.reduce((a, b) => a + b, 0),
                    data: data
                });
                
                overallMean += groupMean * n;
                totalN += n;
            }
            
            if (totalN === 0 || k < 2) {
                throw new Error('ANOVA requires at least 2 groups with data');
            }
            
            overallMean /= totalN;
            
            // Calculate Sum of Squares
            let SSBetween = 0; // Between-group variability
            let SSWithin = 0;  // Within-group variability
            
            for (const group of groupStats) {
                // Between-group sum of squares
                SSBetween += group.n * Math.pow(group.mean - overallMean, 2);
                
                // Within-group sum of squares
                SSWithin += (group.n - 1) * group.variance;
            }
            
            const SSTotal = SSBetween + SSWithin;
            
            // Calculate degrees of freedom
            const dfBetween = k - 1;
            const dfWithin = totalN - k;
            const dfTotal = totalN - 1;
            
            // Calculate Mean Squares
            const MSBetween = SSBetween / dfBetween;
            const MSWithin = SSWithin / dfWithin;
            
            // Calculate F-statistic
            const F = MSBetween / MSWithin;
            
            // Calculate p-value
            const pValue = 1 - jStat.centralF.cdf(F, dfBetween, dfWithin);
            
            // Calculate effect size (Eta squared)
            const etaSquared = SSBetween / SSTotal;
            
            return {
                F, pValue,
                dfBetween, dfWithin, dfTotal,
                SSBetween, SSWithin, SSTotal,
                MSBetween, MSWithin,
                overallMean, totalN,
                groupStats,
                etaSquared
            };
        }
        
        function confidenceIntervalMean(data, confidenceLevel = 0.95) {
            const n = data.length;
            const sampleMean = mean(data);
            const sampleStd = stdDev(data);
            const stdError = sampleStd / Math.sqrt(n);
            const z = jStat.normal.inv(1 - (1 - confidenceLevel) / 2, 0, 1);
            const margin = z * stdError;
            
            return {
                lower: sampleMean - margin,
                upper: sampleMean + margin,
                mean: sampleMean,
                margin: margin
            };
        }
        
        function confidenceIntervalProportion(count, total, confidenceLevel = 0.95) {
            const p = count / total;
            const z = jStat.normal.inv(1 - (1 - confidenceLevel) / 2, 0, 1);
            const margin = z * Math.sqrt(p * (1 - p) / total);
            
            return {
                lower: Math.max(0, p - margin),
                upper: Math.min(1, p + margin),
                proportion: p,
                margin: margin
            };
        }
        
        // Chart Creation Functions - ALL DEFINED
        function createBarChartConfig(variableName, data) {
            const counts = {};
            data.forEach(value => {
                const key = String(value);
                counts[key] = (counts[key] || 0) + 1;
            });
            
            const labels = Object.keys(counts);
            const values = Object.values(counts);
            const total = values.reduce((a, b) => a + b, 0);
            
            // Generate colors
            const colors = labels.map((_, i) => {
                const hue = (i * 137) % 360;
                return `hsla(${hue}, 70%, 60%, 0.7)`;
            });
            
            return {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: `Frequency of ${variableName}`,
                        data: values,
                        backgroundColor: colors,
                        borderColor: colors.map(c => c.replace('0.7', '1')),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `Bar Plot: ${variableName}`,
                            font: { size: 16 }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const percentage = ((context.raw / total) * 100).toFixed(1);
                                    return `${context.label}: ${context.raw} (${percentage}%)`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Frequency'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: variableName
                            }
                        }
                    }
                }
            };
        }
        
        function createHistogramConfig(variableName, data) {
            // Calculate optimal number of bins
            const n = data.length;
            const binCount = Math.min(15, Math.ceil(Math.sqrt(n)));
            
            // Find min and max
            const min = Math.min(...data);
            const max = Math.max(...data);
            const range = max - min;
            const binWidth = range / binCount;
            
            // Create bins
            const bins = Array(binCount).fill(0);
            const labels = [];
            
            for (let i = 0; i < binCount; i++) {
                const binStart = min + i * binWidth;
                const binEnd = binStart + binWidth;
                labels.push(`${binStart.toFixed(1)}-${binEnd.toFixed(1)}`);
                
                // Count values in this bin
                data.forEach(value => {
                    if (value >= binStart && (i === binCount - 1 ? value <= binEnd : value < binEnd)) {
                        bins[i]++;
                    }
                });
            }
            
            return {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: `Frequency`,
                        data: bins,
                        backgroundColor: 'rgba(74, 111, 165, 0.7)',
                        borderColor: 'rgba(74, 111, 165, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `Histogram: ${variableName}`,
                            font: { size: 16 }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Frequency'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: variableName
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45
                            }
                        }
                    }
                }
            };
        }
        
        function createBoxPlotConfig(variableName, data) {
            const sorted = [...data].sort((a, b) => a - b);
            const q1 = sorted[Math.floor(sorted.length * 0.25)];
            const median = sorted[Math.floor(sorted.length * 0.5)];
            const q3 = sorted[Math.floor(sorted.length * 0.75)];
            const iqr = q3 - q1;
            const minVal = Math.max(sorted[0], q1 - 1.5 * iqr);
            const maxVal = Math.min(sorted[sorted.length - 1], q3 + 1.5 * iqr);
            
            // Find outliers
            const outliers = data.filter(x => x < q1 - 1.5 * iqr || x > q3 + 1.5 * iqr);
            
            return {
                type: 'boxplot',
                data: {
                    labels: [variableName],
                    datasets: [{
                        label: variableName,
                        data: [[minVal, q1, median, q3, maxVal]],
                        backgroundColor: 'rgba(74, 111, 165, 0.5)',
                        borderColor: 'rgba(74, 111, 165, 1)',
                        borderWidth: 2,
                        outlierColor: 'rgba(231, 76, 60, 0.8)',
                        outlierRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `Box Plot: ${variableName}`,
                            font: { size: 16 }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const values = context.raw;
                                    return [
                                        `Minimum: ${values[0].toFixed(2)}`,
                                        `Q1: ${values[1].toFixed(2)}`,
                                        `Median: ${values[2].toFixed(2)}`,
                                        `Q3: ${values[3].toFixed(2)}`,
                                        `Maximum: ${values[4].toFixed(2)}`,
                                        `Outliers: ${outliers.length}`
                                    ];
                                }
                            }
                        }
                    }
                }
            };
        }
        
        function createScatterPlotConfig(var1, var2, var1Data, var2Data) {
            // Pair the data
            const pairedData = [];
            const n = Math.min(var1Data.length, var2Data.length);
            
            for (let i = 0; i < n; i++) {
                pairedData.push({ x: var1Data[i], y: var2Data[i] });
            }
            
            // Calculate correlation
            const corr = correlation(var1Data.slice(0, n), var2Data.slice(0, n));
            
            return {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: `${var1} vs ${var2}`,
                        data: pairedData,
                        backgroundColor: 'rgba(74, 111, 165, 0.7)',
                        borderColor: 'rgba(74, 111, 165, 1)',
                        pointRadius: 5,
                        pointHoverRadius: 8
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `Scatter Plot: ${var1} vs ${var2} (r = ${isNaN(corr) ? 'N/A' : corr.toFixed(3)})`,
                            font: { size: 16 }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: var1
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: var2
                            }
                        }
                    }
                }
            };
        }
        
        function createGroupedBarChartConfig(var1, var2, var1Data, var2Data) {
            const categories1 = [...new Set(var1Data.map(String))];
            const categories2 = [...new Set(var2Data.map(String))];
            
            // Create contingency table
            const counts = {};
            categories1.forEach(cat1 => {
                counts[cat1] = {};
                categories2.forEach(cat2 => {
                    counts[cat1][cat2] = 0;
                });
            });
            
            const n = Math.min(var1Data.length, var2Data.length);
            for (let i = 0; i < n; i++) {
                const cat1 = String(var1Data[i]);
                const cat2 = String(var2Data[i]);
                if (counts[cat1] && counts[cat1][cat2] !== undefined) {
                    counts[cat1][cat2]++;
                }
            }
            
            // Create datasets for each category2
            const datasets = categories2.map((cat2, index) => {
                const hue = (index * 137) % 360;
                return {
                    label: cat2,
                    data: categories1.map(cat1 => counts[cat1][cat2] || 0),
                    backgroundColor: `hsla(${hue}, 70%, 60%, 0.7)`,
                    borderColor: `hsla(${hue}, 70%, 50%, 1)`,
                    borderWidth: 1
                };
            });
            
            return {
                type: 'bar',
                data: {
                    labels: categories1,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `${var1} by ${var2}`,
                            font: { size: 16 }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Frequency'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: var1
                            }
                        }
                    }
                }
            };
        }
        
        function createGroupedBoxPlotConfig(catVar, contVar, catData, contData) {
            const categories = [...new Set(catData.map(String))];
            const groupedData = {};
            
            categories.forEach(cat => {
                groupedData[cat] = [];
            });
            
            const n = Math.min(catData.length, contData.length);
            for (let i = 0; i < n; i++) {
                const cat = String(catData[i]);
                if (groupedData[cat]) {
                    groupedData[cat].push(contData[i]);
                }
            }
            
            // Calculate box plot values for each category
            const datasets = [{
                label: contVar,
                data: categories.map(cat => {
                    const values = groupedData[cat];
                    if (values.length === 0) return [0, 0, 0, 0, 0];
                    
                    const sorted = values.sort((a, b) => a - b);
                    const q1 = sorted[Math.floor(sorted.length * 0.25)];
                    const median = sorted[Math.floor(sorted.length * 0.5)];
                    const q3 = sorted[Math.floor(sorted.length * 0.75)];
                    const iqr = q3 - q1;
                    const min = Math.max(sorted[0], q1 - 1.5 * iqr);
                    const max = Math.min(sorted[sorted.length - 1], q3 + 1.5 * iqr);
                    
                    return [min, q1, median, q3, max];
                }),
                backgroundColor: 'rgba(74, 111, 165, 0.5)',
                borderColor: 'rgba(74, 111, 165, 1)',
                borderWidth: 2
            }];
            
            return {
                type: 'boxplot',
                data: {
                    labels: categories,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `${contVar} by ${catVar}`,
                            font: { size: 16 }
                        }
                    },
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: contVar
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: catVar
                            }
                        }
                    }
                }
            };
        }
        
        // Data handling functions
        function handleFileUpload(file) {
            if (!file.name.toLowerCase().endsWith('.csv')) {
                showUploadError('Please upload a CSV file.');
                return;
            }
            
            if (file.size > 5 * 1024 * 1024) {
                showUploadError('File size must be less than 5MB.');
                return;
            }
            
            // Show loading state
            resultsContainer.innerHTML = '<div class="loading">Loading and analyzing data...</div>';
            
            Papa.parse(file, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    if (results.errors.length) {
                        showUploadError('Error parsing CSV file: ' + results.errors[0].message);
                        resultsContainer.innerHTML = '<div class="status-message">Error loading data. Please try again.</div>';
                        return;
                    }
                    
                    csvData = results.data;
                    headers = results.meta.fields;
                    
                    if (csvData.length === 0) {
                        showUploadError('CSV file is empty or could not be parsed.');
                        resultsContainer.innerHTML = '<div class="status-message">No data found in file.</div>';
                        return;
                    }
                    
                    determineColumnTypes();
                    updateDataPreview();
                    updateVariableSelects();
                    clearUploadError();
                    dataPreview.style.display = 'block';
                    analyzeBtn.disabled = false;
                    dataLoadedMessage.classList.add('active');
                    
                    dataInfo.textContent = `Loaded ${csvData.length} rows with ${headers.length} variables.`;
                    
                    // Auto-select first variable
                    setTimeout(() => {
                        if (headers.length >= 1) {
                            var1Select.value = headers[1]; // Use "Score" as default
                            var1Select.dispatchEvent(new Event('change'));
                        }
                    }, 500);
                },
                error: function(error) {
                    showUploadError('Error reading file: ' + error.message);
                    resultsContainer.innerHTML = '<div class="status-message">Error loading data. Please try again.</div>';
                }
            });
        }
        
        function determineColumnTypes() {
            columnTypes = {};
            
            headers.forEach(header => {
                const sampleValues = csvData
                    .map(row => row[header])
                    .filter(val => val !== null && val !== undefined && val !== '')
                    .slice(0, 50);
                
                if (sampleValues.length === 0) {
                    columnTypes[header] = 'unknown';
                    return;
                }
                
                // Check if values are numeric
                const numericCount = sampleValues.filter(val => typeof val === 'number' && !isNaN(val)).length;
                const numericRatio = numericCount / sampleValues.length;
                
                // If more than 70% are numeric, treat as continuous
                if (numericRatio > 0.7) {
                    columnTypes[header] = 'continuous';
                } else {
                    columnTypes[header] = 'categorical';
                }
            });
        }
        
        function updateDataPreview() {
            previewTable.innerHTML = '';
            currentColStart = 0;
            
            // Update column range display
            updateColumnRange();
            
            // Create header row
            let thead = '<tr>';
            const visibleHeaders = headers.slice(currentColStart, currentColStart + visibleCols);
            
            visibleHeaders.forEach(header => {
                const type = columnTypes[header];
                const typeIcon = type === 'continuous' ? 'ðŸ”¢' : 'ðŸ“Š';
                thead += `<th title="${type === 'continuous' ? 'Continuous variable' : 'Categorical variable'}">${header} ${typeIcon}</th>`;
            });
            thead += '</tr>';
            previewTable.innerHTML = thead;
            
            // Create data rows (first 10 rows only)
            const previewRows = Math.min(10, csvData.length);
            for (let i = 0; i < previewRows; i++) {
                let row = '<tr>';
                visibleHeaders.forEach(header => {
                    const value = csvData[i][header];
                    const displayValue = value !== null && value !== undefined ? value : '<span style="color:#999">null</span>';
                    row += `<td>${displayValue}</td>`;
                });
                row += '</tr>';
                previewTable.innerHTML += row;
            }
        }
        
        function navigateColumns(direction) {
            const newStart = currentColStart + direction;
            
            // Check bounds
            if (newStart < 0 || newStart >= headers.length) {
                return;
            }
            
            currentColStart = newStart;
            
            // Clear table and rebuild
            previewTable.innerHTML = '';
            
            // Create header row
            let thead = '<tr>';
            const endCol = Math.min(currentColStart + visibleCols, headers.length);
            const visibleHeaders = headers.slice(currentColStart, endCol);
            
            visibleHeaders.forEach(header => {
                const type = columnTypes[header];
                const typeIcon = type === 'continuous' ? 'ðŸ”¢' : 'ðŸ“Š';
                thead += `<th title="${type === 'continuous' ? 'Continuous variable' : 'Categorical variable'}">${header} ${typeIcon}</th>`;
            });
            thead += '</tr>';
            previewTable.innerHTML = thead;
            
            // Create data rows
            const previewRows = Math.min(10, csvData.length);
            for (let i = 0; i < previewRows; i++) {
                let row = '<tr>';
                visibleHeaders.forEach(header => {
                    const value = csvData[i][header];
                    const displayValue = value !== null && value !== undefined ? value : '<span style="color:#999">null</span>';
                    row += `<td>${displayValue}</td>`;
                });
                row += '</tr>';
                previewTable.innerHTML += row;
            }
            
            // Update navigation buttons and range display
            updateColumnRange();
        }
        
        function updateColumnRange() {
            const start = currentColStart + 1;
            const end = Math.min(currentColStart + visibleCols, headers.length);
            colRangeSpan.textContent = `Columns ${start}-${end} of ${headers.length}`;
            
            // Update button states
            prevColBtn.disabled = currentColStart === 0;
            nextColBtn.disabled = currentColStart + visibleCols >= headers.length;
        }
        
        function updateVariableSelects() {
            var1Select.innerHTML = '<option value="">Select a variable</option>';
            var2Select.innerHTML = '<option value="">Select a variable (optional)</option>';
            
            var1Select.disabled = false;
            var2Select.disabled = false;
            
            headers.forEach(header => {
                const type = columnTypes[header];
                const typeLabel = type === 'continuous' ? ' (Continuous)' : ' (Categorical)';
                
                const option1 = document.createElement('option');
                option1.value = header;
                option1.textContent = header + typeLabel;
                var1Select.appendChild(option1);
                
                const option2 = document.createElement('option');
                option2.value = header;
                option2.textContent = header + typeLabel;
                var2Select.appendChild(option2);
            });
        }
        
        function updateAnalysisOptions() {
            const var1 = var1Select.value;
            const var2 = var2Select.value;
            
            analysisTypeGroup.innerHTML = '';
            testParams.classList.remove('active');
            proportionTestParams.style.display = 'none';
            tTestParams.style.display = 'none';
            propCIParams.style.display = 'none';
            targetCategoryParams.style.display = 'none';
            anovaWarning.style.display = 'none';
            
            if (!var1) {
                analyzeBtn.disabled = true;
                analysisTypeGroup.innerHTML = '<div class="status-message">Select variables to see analysis options</div>';
                return;
            }
            
            analyzeBtn.disabled = false;
            const var1Type = columnTypes[var1];
            const var2Type = var2 ? columnTypes[var2] : null;
            
            let options = [];
            
            if (!var2) {
                // Single variable analysis
                if (var1Type === 'categorical') {
                    options = [
                        { value: 'barplot', label: 'Bar Plot' },
                        { value: 'proportion_test', label: 'Test of Proportion' },
                        { value: 'proportion_ci', label: 'Confidence Interval for Proportion' }
                    ];
                } else {
                    options = [
                        { value: 'histogram', label: 'Histogram' },
                        { value: 'boxplot', label: 'Box Plot' },
                        { value: 'mean_ci', label: 'Confidence Interval for Mean' },
                        { value: 't_test', label: 'One-sample T-test' }
                    ];
                }
            } else {
                // Two variable analysis
                if (var1Type === 'categorical' && var2Type === 'categorical') {
                    options = [
                        { value: 'grouped_bar', label: 'Grouped Bar Plot' },
                        { value: 'chi_square', label: 'Chi-square Test of Independence' }
                    ];
                } else if (var1Type === 'categorical' && var2Type === 'continuous') {
                    // Check number of categories
                    const categories = [...new Set(csvData.map(row => row[var1]).filter(val => val != null))];
                    const numCategories = categories.length;
                    
                    if (numCategories === 2) {
                        options = [
                            { value: 'boxplot_group', label: 'Box Plot by Group' },
                            { value: 'two_sample_t', label: 'Two-sample T-test' }
                        ];
                    } else if (numCategories > 2) {
                        options = [
                            { value: 'boxplot_group', label: 'Box Plot by Group' },
                            { value: 'anova', label: 'One-way ANOVA' }
                        ];
                        anovaWarning.style.display = 'block';
                    } else {
                        options = [
                            { value: 'boxplot_group', label: 'Box Plot by Group' }
                        ];
                    }
                } else if (var1Type === 'continuous' && var2Type === 'continuous') {
                    options = [
                        { value: 'scatter', label: 'Scatter Plot' },
                        { value: 'correlation', label: 'Correlation Analysis' }
                    ];
                } else if (var1Type === 'continuous' && var2Type === 'categorical') {
                    // Check number of categories
                    const categories = [...new Set(csvData.map(row => row[var2]).filter(val => val != null))];
                    const numCategories = categories.length;
                    
                    if (numCategories === 2) {
                        options = [
                            { value: 'boxplot_group', label: 'Box Plot by Group' },
                            { value: 'two_sample_t', label: 'Two-sample T-test' }
                        ];
                    } else if (numCategories > 2) {
                        options = [
                            { value: 'boxplot_group', label: 'Box Plot by Group' },
                            { value: 'anova', label: 'One-way ANOVA' }
                        ];
                        anovaWarning.style.display = 'block';
                    } else {
                        options = [
                            { value: 'boxplot_group', label: 'Box Plot by Group' }
                        ];
                    }
                }
            }
            
            // Create radio buttons
            options.forEach((option, index) => {
                const div = document.createElement('div');
                div.className = 'radio-option';
                
                const input = document.createElement('input');
                input.type = 'radio';
                input.id = `analysis_${option.value}`;
                input.name = 'analysisType';
                input.value = option.value;
                input.addEventListener('change', function() {
                    updateTestParams(option.value, var1, var1Type);
                });
                if (index === 0) input.checked = true;
                
                const label = document.createElement('label');
                label.htmlFor = `analysis_${option.value}`;
                label.textContent = option.label;
                
                div.appendChild(input);
                div.appendChild(label);
                analysisTypeGroup.appendChild(div);
            });
            
            updateTestParams(options[0].value, var1, var1Type);
            updateHelpPopup(var1Type, var2Type);
        }
        
        function updateTestParams(analysisType, var1, var1Type) {
            testParams.classList.add('active');
            proportionTestParams.style.display = 'none';
            tTestParams.style.display = 'none';
            propCIParams.style.display = 'none';
            targetCategoryParams.style.display = 'none';
            
            if (analysisType === 'proportion_test') {
                proportionTestParams.style.display = 'block';
            } else if (analysisType === 't_test') {
                tTestParams.style.display = 'block';
            } else if (analysisType === 'mean_ci' || analysisType === 'proportion_ci') {
                propCIParams.style.display = 'block';
                
                if (analysisType === 'proportion_ci' && var1Type === 'categorical') {
                    targetCategoryParams.style.display = 'block';
                    // Populate target category dropdown
                    targetCategorySelect.innerHTML = '<option value="">Select a category</option>';
                    
                    const categories = [...new Set(csvData.map(row => row[var1]).filter(val => val != null))];
                    categories.forEach(category => {
                        const option = document.createElement('option');
                        option.value = category;
                        option.textContent = category;
                        targetCategorySelect.appendChild(option);
                    });
                    
                    if (categories.length > 0) {
                        targetCategorySelect.value = categories[0];
                    }
                }
            }
        }
        
        function runAnalysis() {
            const var1 = var1Select.value;
            const var2 = var2Select.value;
            const analysisType = document.querySelector('input[name="analysisType"]:checked').value;
            
            if (!var1) {
                alert('Please select at least one variable.');
                return;
            }
            
            // Check for proportion CI target category
            if (analysisType === 'proportion_ci' && !targetCategorySelect.value) {
                alert('Please select a target category for the confidence interval.');
                return;
            }
            
            // Show loading state
            resultsContainer.innerHTML = '<div class="loading">Running analysis... This may take a moment.</div>';
            
            // Clear previous chart
            if (currentChart) {
                currentChart.destroy();
                currentChart = null;
            }
            
            // Run analysis after a short delay to show loading state
            setTimeout(() => {
                performAnalysis(var1, var2, analysisType);
            }, 300);
        }
        
        function performAnalysis(var1, var2, analysisType) {
            const var1Type = columnTypes[var1];
            const var2Type = var2 ? columnTypes[var2] : null;
            
            // Extract clean data for selected variables
            const var1Data = csvData
                .map(row => row[var1])
                .filter(val => val != null && val !== '');
            
            const var2Data = var2 ? csvData
                .map(row => row[var2])
                .filter(val => val != null && val !== '') : null;
            
            if (var1Data.length === 0) {
                resultsContainer.innerHTML = '<div class="error-message active">No valid data found for the selected variable.</div>';
                return;
            }
            
            // Clear previous results
            resultsContainer.innerHTML = '';
            
            // Create results container with grid layout
            const resultsGrid = document.createElement('div');
            resultsGrid.className = 'analysis-results';
            resultsContainer.appendChild(resultsGrid);
            
            // Chart container
            const chartContainer = document.createElement('div');
            chartContainer.className = 'chart-container analysis-chart';
            
            const canvas = document.createElement('canvas');
            canvas.id = 'chartCanvas';
            chartContainer.appendChild(canvas);
            resultsGrid.appendChild(chartContainer);
            
            // Statistics container
            const statsContainer = document.createElement('div');
            statsContainer.className = 'analysis-stats';
            resultsGrid.appendChild(statsContainer);
            
            let chartConfig = null;
            let statsText = '';
            
            console.log(`Running analysis: ${analysisType} on ${var1}${var2 ? ' and ' + var2 : ''}`);
            
            // Perform the selected analysis
            try {
                if (!var2) {
                    // Single variable analysis
                    if (var1Type === 'categorical') {
                        if (analysisType === 'barplot') {
                            chartConfig = createBarChartConfig(var1, var1Data);
                            statsText = performCategoricalAnalysis(var1, var1Data);
                        } else if (analysisType === 'proportion_test') {
                            chartConfig = createBarChartConfig(var1, var1Data);
                            const expectedProportions = document.getElementById('expectedProportions').value
                                .split(',')
                                .map(p => parseFloat(p.trim()));
                            statsText = performProportionTest(var1, var1Data, expectedProportions);
                        } else if (analysisType === 'proportion_ci') {
                            chartConfig = createBarChartConfig(var1, var1Data);
                            const confidenceLevel = parseFloat(document.getElementById('confidenceLevel').value) / 100;
                            const targetCategory = targetCategorySelect.value;
                            statsText = performProportionCI(var1, var1Data, confidenceLevel, targetCategory);
                        }
                    } else {
                        // Continuous variable
                        if (analysisType === 'histogram') {
                            chartConfig = createHistogramConfig(var1, var1Data);
                            statsText = performContinuousAnalysis(var1, var1Data);
                        } else if (analysisType === 'boxplot') {
                            chartConfig = createBoxPlotConfig(var1, var1Data);
                            statsText = performContinuousAnalysis(var1, var1Data);
                        } else if (analysisType === 'mean_ci') {
                            chartConfig = createHistogramConfig(var1, var1Data);
                            const confidenceLevel = parseFloat(document.getElementById('confidenceLevel').value) / 100;
                            statsText = performMeanCI(var1, var1Data, confidenceLevel);
                        } else if (analysisType === 't_test') {
                            chartConfig = createHistogramConfig(var1, var1Data);
                            const testValue = parseFloat(document.getElementById('testValue').value);
                            statsText = performOneSampleTTest(var1, var1Data, testValue);
                        }
                    }
                } else {
                    // Two variable analysis
                    if (var1Type === 'categorical' && var2Type === 'categorical') {
                        if (analysisType === 'grouped_bar') {
                            chartConfig = createGroupedBarChartConfig(var1, var2, var1Data, var2Data);
                            statsText = performTwoCategoricalAnalysis(var1, var2, var1Data, var2Data);
                        } else if (analysisType === 'chi_square') {
                            chartConfig = createGroupedBarChartConfig(var1, var2, var1Data, var2Data);
                            statsText = performChiSquareTest(var1, var2, var1Data, var2Data);
                        }
                    } else if ((var1Type === 'categorical' && var2Type === 'continuous') || 
                              (var1Type === 'continuous' && var2Type === 'categorical')) {
                        const catVar = var1Type === 'categorical' ? var1 : var2;
                        const contVar = var1Type === 'continuous' ? var1 : var2;
                        const catData = var1Type === 'categorical' ? var1Data : var2Data;
                        const contData = var1Type === 'continuous' ? var1Data : var2Data;
                        
                        if (analysisType === 'boxplot_group') {
                            chartConfig = createGroupedBoxPlotConfig(catVar, contVar, catData, contData);
                            statsText = performCategoricalContinuousAnalysis(catVar, contVar, catData, contData);
                        } else if (analysisType === 'two_sample_t') {
                            chartConfig = createGroupedBoxPlotConfig(catVar, contVar, catData, contData);
                            statsText = performTwoSampleTTestAnalysis(catVar, contVar, catData, contData);
                        } else if (analysisType === 'anova') {
                            chartConfig = createGroupedBoxPlotConfig(catVar, contVar, catData, contData);
                            statsText = performAnovaAnalysis(catVar, contVar, catData, contData);
                        }
                    } else if (var1Type === 'continuous' && var2Type === 'continuous') {
                        if (analysisType === 'scatter') {
                            chartConfig = createScatterPlotConfig(var1, var2, var1Data, var2Data);
                            statsText = performTwoContinuousAnalysis(var1, var2, var1Data, var2Data);
                        } else if (analysisType === 'correlation') {
                            chartConfig = createScatterPlotConfig(var1, var2, var1Data, var2Data);
                            statsText = performCorrelationAnalysis(var1, var2, var1Data, var2Data);
                        }
                    }
                }
                
                // Display the chart
                if (chartConfig) {
                    const ctx = canvas.getContext('2d');
                    currentChart = new Chart(ctx, chartConfig);
                } else {
                    chartContainer.innerHTML = '<div class="status-message">No chart available for this analysis type.</div>';
                }
                
                // Display statistics
                const statsOutput = document.createElement('div');
                statsOutput.className = 'statistics-output';
                statsOutput.innerHTML = formatStatsText(statsText);
                statsContainer.appendChild(statsOutput);
                
            } catch (error) {
                console.error('Analysis error:', error);
                resultsContainer.innerHTML = `
                    <div class="error-message active">
                        <strong>Analysis Error:</strong> ${error.message}<br>
                        Please check your data and try again.
                    </div>
                `;
            }
        }
        
        function formatStatsText(statsText) {
            // Convert plain text to HTML with formatting
            const lines = statsText.split('\n');
            let html = '';
            
            lines.forEach(line => {
                if (line.includes('===')) {
                    // Section header
                    html += `<div class="stat-header">${line.replace(/=/g, '')}</div>`;
                } else if (line.includes(':')) {
                    // Stat item with colon
                    const parts = line.split(':');
                    html += `<div class="stat-item"><strong>${parts[0]}:</strong> <span class="stat-value">${parts.slice(1).join(':')}</span></div>`;
                } else if (line.trim()) {
                    // Regular line
                    html += `<div>${line}</div>`;
                } else {
                    // Empty line
                    html += '<br>';
                }
            });
            
            return html;
        }
        
        // Analysis functions - ALL DEFINED
        function performCategoricalAnalysis(variableName, data) {
            const counts = {};
            data.forEach(value => {
                const key = String(value);
                counts[key] = (counts[key] || 0) + 1;
            });
            
            const categories = Object.keys(counts);
            const total = data.length;
            
            let stats = `=== CATEGORICAL VARIABLE ANALYSIS ===\n\n`;
            stats += `Variable: ${variableName}\n`;
            stats += `Total observations: ${total}\n`;
            stats += `Number of categories: ${categories.length}\n\n`;
            
            stats += `=== FREQUENCY DISTRIBUTION ===\n`;
            
            // Sort by frequency descending
            const sortedCategories = categories.sort((a, b) => counts[b] - counts[a]);
            
            sortedCategories.forEach(category => {
                const count = counts[category];
                const percentage = (count / total * 100).toFixed(2);
                stats += `${category}: ${count} (${percentage}%)\n`;
            });
            
            stats += `\n=== DESCRIPTIVE STATISTICS ===\n`;
            stats += `Mode: ${sortedCategories[0]}\n`;
            stats += `Shannon Entropy: ${calculateEntropy(counts, total).toFixed(4)}\n`;
            
            // Calculate chi-square for equal proportions
            const observed = Object.values(counts);
            const expected = Array(observed.length).fill(total / observed.length);
            const chi2Result = chiSquareGoodnessOfFit(observed, expected);
            
            stats += `\n=== TEST FOR EQUAL PROPORTIONS ===\n`;
            stats += `Chi-square statistic: ${chi2Result.chi2.toFixed(4)}\n`;
            stats += `Degrees of freedom: ${chi2Result.df}\n`;
            stats += `P-value: ${chi2Result.pValue.toFixed(6)}\n`;
            
            if (chi2Result.pValue < 0.05) {
                stats += `Interpretation: Significant evidence against equal proportions (p < 0.05)\n`;
            } else {
                stats += `Interpretation: No significant evidence against equal proportions (p â‰¥ 0.05)\n`;
            }
            
            return stats;
        }
        
        function calculateEntropy(counts, total) {
            let entropy = 0;
            for (const count of Object.values(counts)) {
                const p = count / total;
                if (p > 0) {
                    entropy -= p * Math.log2(p);
                }
            }
            return entropy;
        }
        
        function performProportionTest(variableName, data, expectedProportions) {
            const counts = {};
            data.forEach(value => {
                const key = String(value);
                counts[key] = (counts[key] || 0) + 1;
            });
            
            const categories = Object.keys(counts);
            const observed = Object.values(counts);
            const total = data.length;
            
            let stats = `=== CHI-SQUARE GOODNESS-OF-FIT TEST ===\n\n`;
            stats += `Variable: ${variableName}\n`;
            stats += `Total observations: ${total}\n\n`;
            
            // If no expected proportions provided, assume equal distribution
            let expected = expectedProportions;
            if (!expected || expected.length !== categories.length || expected.some(isNaN)) {
                expected = Array(categories.length).fill(total / categories.length);
                stats += `Expected proportions: Equal distribution\n\n`;
            } else {
                expected = expected.map(p => p * total);
                stats += `Expected proportions: Provided by user\n\n`;
            }
            
            stats += `=== OBSERVED vs EXPECTED FREQUENCIES ===\n`;
            categories.forEach((cat, i) => {
                const obsPercent = (observed[i] / total * 100).toFixed(1);
                const expPercent = (expected[i] / total * 100).toFixed(1);
                stats += `${cat}: Observed = ${observed[i]} (${obsPercent}%), Expected = ${expected[i].toFixed(1)} (${expPercent}%)\n`;
            });
            
            const result = chiSquareGoodnessOfFit(observed, expected);
            
            stats += `\n=== TEST RESULTS ===\n`;
            stats += `Chi-square statistic: ${result.chi2.toFixed(4)}\n`;
            stats += `Degrees of freedom: ${result.df}\n`;
            stats += `P-value: ${result.pValue.toFixed(6)}\n\n`;
            
            stats += `=== INTERPRETATION ===\n`;
            if (result.pValue < 0.05) {
                stats += `Significant at Î±=0.05: REJECT null hypothesis\n`;
                stats += `The observed proportions differ significantly from expected proportions.\n`;
            } else {
                stats += `Not significant at Î±=0.05: FAIL TO REJECT null hypothesis\n`;
                stats += `No significant difference between observed and expected proportions.\n`;
            }
            
            return stats;
        }
        
        function performProportionCI(variableName, data, confidenceLevel, targetCategory) {
            const counts = {};
            data.forEach(value => {
                const key = String(value);
                counts[key] = (counts[key] || 0) + 1;
            });
            
            const total = data.length;
            const targetCount = counts[targetCategory] || 0;
            
            let stats = `=== CONFIDENCE INTERVAL FOR PROPORTION ===\n\n`;
            stats += `Variable: ${variableName}\n`;
            stats += `Target category: ${targetCategory}\n`;
            stats += `Total observations: ${total}\n`;
            stats += `Confidence level: ${(confidenceLevel * 100).toFixed(1)}%\n\n`;
            
            stats += `=== SAMPLE STATISTICS ===\n`;
            stats += `Count for "${targetCategory}": ${targetCount}\n`;
            stats += `Sample proportion: ${(targetCount / total * 100).toFixed(2)}%\n\n`;
            
            const ci = confidenceIntervalProportion(targetCount, total, confidenceLevel);
            
            stats += `=== CONFIDENCE INTERVAL ===\n`;
            stats += `${(confidenceLevel * 100).toFixed(1)}% CI: [${(ci.lower * 100).toFixed(2)}%, ${(ci.upper * 100).toFixed(2)}%]\n`;
            stats += `Margin of error: Â±${(ci.margin * 100).toFixed(2)}%\n`;
            stats += `Width of interval: ${((ci.upper - ci.lower) * 100).toFixed(2)}%\n\n`;
            
            stats += `=== INTERPRETATION ===\n`;
            stats += `We are ${(confidenceLevel * 100).toFixed(1)}% confident that the true population\n`;
            stats += `proportion for "${targetCategory}" is between ${(ci.lower * 100).toFixed(2)}% and ${(ci.upper * 100).toFixed(2)}%.\n`;
            
            return stats;
        }
        
        function performContinuousAnalysis(variableName, data) {
            const n = data.length;
            const m = mean(data);
            const med = median(data);
            const sd = stdDev(data);
            const q = quartiles(data);
            const min = Math.min(...data);
            const max = Math.max(...data);
            const range = max - min;
            const iqr = q.q3 - q.q1;
            const cv = (sd / m * 100).toFixed(2);
            
            let stats = `=== CONTINUOUS VARIABLE ANALYSIS ===\n\n`;
            stats += `Variable: ${variableName}\n`;
            stats += `Sample size (n): ${n}\n\n`;
            
            stats += `=== DESCRIPTIVE STATISTICS ===\n`;
            stats += `Mean: ${m.toFixed(4)}\n`;
            stats += `Median: ${med.toFixed(4)}\n`;
            stats += `Standard Deviation: ${sd.toFixed(4)}\n`;
            stats += `Variance: ${(sd * sd).toFixed(4)}\n`;
            stats += `Coefficient of Variation: ${cv}%\n`;
            stats += `Minimum: ${min.toFixed(4)}\n`;
            stats += `Maximum: ${max.toFixed(4)}\n`;
            stats += `Range: ${range.toFixed(4)}\n`;
            stats += `Q1 (25th percentile): ${q.q1.toFixed(4)}\n`;
            stats += `Q3 (75th percentile): ${q.q3.toFixed(4)}\n`;
            stats += `Interquartile Range (IQR): ${iqr.toFixed(4)}\n\n`;
            
            // Check for outliers
            const lowerBound = q.q1 - 1.5 * iqr;
            const upperBound = q.q3 + 1.5 * iqr;
            const outliers = data.filter(x => x < lowerBound || x > upperBound);
            stats += `=== OUTLIER DETECTION ===\n`;
            stats += `Lower bound (Q1 - 1.5*IQR): ${lowerBound.toFixed(4)}\n`;
            stats += `Upper bound (Q3 + 1.5*IQR): ${upperBound.toFixed(4)}\n`;
            stats += `Potential outliers: ${outliers.length} (${(outliers.length / n * 100).toFixed(1)}%)\n`;
            
            // Normality test (simplified)
            const skewness = calculateSkewness(data);
            stats += `\n=== DISTRIBUTION SHAPE ===\n`;
            stats += `Skewness: ${skewness.toFixed(4)}\n`;
            if (Math.abs(skewness) > 1) {
                stats += `Interpretation: Highly skewed distribution\n`;
            } else if (Math.abs(skewness) > 0.5) {
                stats += `Interpretation: Moderately skewed distribution\n`;
            } else {
                stats += `Interpretation: Approximately symmetric distribution\n`;
            }
            
            return stats;
        }
        
        function calculateSkewness(data) {
            const n = data.length;
            const m = mean(data);
            const sd = stdDev(data);
            
            if (sd === 0) return 0;
            
            const sumCubes = data.reduce((sum, x) => sum + Math.pow(x - m, 3), 0);
            return (sumCubes / n) / Math.pow(sd, 3);
        }
        
        function performMeanCI(variableName, data, confidenceLevel) {
            const n = data.length;
            const ci = confidenceIntervalMean(data, confidenceLevel);
            const sd = stdDev(data);
            
            let stats = `=== CONFIDENCE INTERVAL FOR MEAN ===\n\n`;
            stats += `Variable: ${variableName}\n`;
            stats += `Sample size (n): ${n}\n`;
            stats += `Confidence level: ${(confidenceLevel * 100).toFixed(1)}%\n\n`;
            
            stats += `=== SAMPLE STATISTICS ===\n`;
            stats += `Sample mean: ${ci.mean.toFixed(4)}\n`;
            stats += `Sample standard deviation: ${sd.toFixed(4)}\n`;
            stats += `Standard error: ${(sd / Math.sqrt(n)).toFixed(4)}\n\n`;
            
            stats += `=== CONFIDENCE INTERVAL ===\n`;
            stats += `${(confidenceLevel * 100).toFixed(1)}% CI: [${ci.lower.toFixed(4)}, ${ci.upper.toFixed(4)}]\n`;
            stats += `Margin of error: Â±${ci.margin.toFixed(4)}\n`;
            stats += `Width of interval: ${(ci.upper - ci.lower).toFixed(4)}\n\n`;
            
            stats += `=== INTERPRETATION ===\n`;
            stats += `We are ${(confidenceLevel * 100).toFixed(1)}% confident that the true population\n`;
            stats += `mean is between ${ci.lower.toFixed(4)} and ${ci.upper.toFixed(4)}.\n`;
            
            return stats;
        }
        
        function performOneSampleTTest(variableName, data, mu0) {
            const result = tTestOneSample(data, mu0);
            const n = data.length;
            const sd = stdDev(data);
            
            let stats = `=== ONE-SAMPLE T-TEST ===\n\n`;
            stats += `Variable: ${variableName}\n`;
            stats += `Sample size (n): ${n}\n`;
            stats += `Hypothesized mean (Î¼â‚€): ${mu0.toFixed(4)}\n\n`;
            
            stats += `=== SAMPLE STATISTICS ===\n`;
            stats += `Sample mean: ${result.sampleMean.toFixed(4)}\n`;
            stats += `Sample standard deviation: ${sd.toFixed(4)}\n`;
            stats += `Standard error: ${result.stdError.toFixed(4)}\n\n`;
            
            stats += `=== HYPOTHESES ===\n`;
            stats += `Hâ‚€: Î¼ = ${mu0.toFixed(4)} (population mean equals ${mu0.toFixed(4)})\n`;
            stats += `Hâ‚: Î¼ â‰  ${mu0.toFixed(4)} (population mean differs from ${mu0.toFixed(4)})\n\n`;
            
            stats += `=== TEST RESULTS ===\n`;
            stats += `t-statistic: ${result.t.toFixed(4)}\n`;
            stats += `Degrees of freedom: ${result.df}\n`;
            stats += `Two-tailed p-value: ${result.pValue.toFixed(6)}\n\n`;
            
            stats += `=== INTERPRETATION ===\n`;
            const diff = result.sampleMean - mu0;
            const diffPercent = mu0 !== 0 ? (Math.abs(diff) / Math.abs(mu0) * 100).toFixed(1) : 'N/A';
            
            if (result.pValue < 0.05) {
                stats += `Significant at Î±=0.05: REJECT Hâ‚€\n`;
                stats += `The sample mean (${result.sampleMean.toFixed(4)}) is significantly different\n`;
                stats += `from ${mu0.toFixed(4)} (difference: ${diff.toFixed(4)}, p = ${result.pValue.toFixed(4)}).\n`;
            } else {
                stats += `Not significant at Î±=0.05: FAIL TO REJECT Hâ‚€\n`;
                stats += `No significant difference between sample mean (${result.sampleMean.toFixed(4)})\n`;
                stats += `and ${mu0.toFixed(4)} (difference: ${diff.toFixed(4)}, p = ${result.pValue.toFixed(4)}).\n`;
            }
            
            return stats;
        }
        
        function performTwoSampleTTestAnalysis(catVar, contVar, catData, contData) {
            // Get unique categories
            const categories = [...new Set(catData.map(String))];
            
            if (categories.length !== 2) {
                throw new Error(`Two-sample t-test requires exactly 2 categories. Found ${categories.length} categories.`);
            }
            
            // Separate data by category
            const group1Data = [];
            const group2Data = [];
            
            for (let i = 0; i < catData.length; i++) {
                if (String(catData[i]) === categories[0]) {
                    group1Data.push(contData[i]);
                } else if (String(catData[i]) === categories[1]) {
                    group2Data.push(contData[i]);
                }
            }
            
            if (group1Data.length < 2 || group2Data.length < 2) {
                throw new Error('Each group must have at least 2 observations for t-test');
            }
            
            // Perform both equal and unequal variance t-tests
            const resultEqual = tTestTwoSample(group1Data, group2Data, true);
            const resultUnequal = tTestTwoSample(group1Data, group2Data, false);
            
            let stats = `=== TWO-SAMPLE T-TEST ===\n\n`;
            stats += `Categorical variable: ${catVar}\n`;
            stats += `Continuous variable: ${contVar}\n`;
            stats += `Group 1 (${categories[0]}): n = ${resultEqual.n1}\n`;
            stats += `Group 2 (${categories[1]}): n = ${resultEqual.n2}\n\n`;
            
            stats += `=== GROUP STATISTICS ===\n`;
            stats += `Group 1 (${categories[0]}):\n`;
            stats += `  Mean: ${resultEqual.mean1.toFixed(4)}\n`;
            stats += `  Standard Deviation: ${Math.sqrt(resultEqual.var1).toFixed(4)}\n`;
            stats += `  Variance: ${resultEqual.var1.toFixed(4)}\n\n`;
            
            stats += `Group 2 (${categories[1]}):\n`;
            stats += `  Mean: ${resultEqual.mean2.toFixed(4)}\n`;
            stats += `  Standard Deviation: ${Math.sqrt(resultEqual.var2).toFixed(4)}\n`;
            stats += `  Variance: ${resultEqual.var2.toFixed(4)}\n\n`;
            
            stats += `Mean difference: ${resultEqual.meanDiff.toFixed(4)}\n`;
            stats += `Standard error: ${resultEqual.stdError.toFixed(4)}\n\n`;
            
            stats += `=== HYPOTHESES ===\n`;
            stats += `Hâ‚€: Î¼â‚ = Î¼â‚‚ (population means are equal)\n`;
            stats += `Hâ‚: Î¼â‚ â‰  Î¼â‚‚ (population means are not equal)\n\n`;
            
            stats += `=== TEST RESULTS (Equal variances assumed) ===\n`;
            stats += `t-statistic: ${resultEqual.t.toFixed(4)}\n`;
            stats += `Degrees of freedom: ${resultEqual.df}\n`;
            stats += `Two-tailed p-value: ${resultEqual.pValue.toFixed(6)}\n\n`;
            
            stats += `=== TEST RESULTS (Welch's t-test, unequal variances) ===\n`;
            stats += `t-statistic: ${resultUnequal.t.toFixed(4)}\n`;
            stats += `Degrees of freedom: ${resultUnequal.df.toFixed(2)}\n`;
            stats += `Two-tailed p-value: ${resultUnequal.pValue.toFixed(6)}\n\n`;
            
            // Variance equality test (F-test)
            const varRatio = resultEqual.var1 > resultEqual.var2 ? 
                resultEqual.var1 / resultEqual.var2 : 
                resultEqual.var2 / resultEqual.var1;
            const df1 = resultEqual.n1 - 1;
            const df2 = resultEqual.n2 - 1;
            const pValueVar = 2 * (1 - jStat.centralF.cdf(varRatio, df1, df2));
            
            stats += `=== VARIANCE EQUALITY TEST ===\n`;
            stats += `F-statistic: ${varRatio.toFixed(4)}\n`;
            stats += `P-value: ${pValueVar.toFixed(6)}\n`;
            if (pValueVar < 0.05) {
                stats += `Interpretation: Variances are significantly different (use Welch's t-test)\n`;
            } else {
                stats += `Interpretation: No significant difference in variances (can use equal variance t-test)\n`;
            }
            
            stats += `\n=== INTERPRETATION ===\n`;
            const bestResult = pValueVar < 0.05 ? resultUnequal : resultEqual;
            const testType = pValueVar < 0.05 ? "Welch's t-test (unequal variances)" : "Equal variance t-test";
            
            if (bestResult.pValue < 0.05) {
                stats += `Significant at Î±=0.05: REJECT Hâ‚€ (using ${testType})\n`;
                stats += `There is a significant difference between group means.\n`;
                stats += `Group 1 mean (${bestResult.mean1.toFixed(4)}) is ${bestResult.mean1 > bestResult.mean2 ? 'greater' : 'less'} than\n`;
                stats += `Group 2 mean (${bestResult.mean2.toFixed(4)}) by ${Math.abs(bestResult.meanDiff).toFixed(4)} units.\n`;
            } else {
                stats += `Not significant at Î±=0.05: FAIL TO REJECT Hâ‚€ (using ${testType})\n`;
                stats += `No significant difference between group means.\n`;
            }
            
            return stats;
        }
        
        function performAnovaAnalysis(catVar, contVar, catData, contData) {
            // Get unique categories
            const categories = [...new Set(catData.map(String))];
            
            if (categories.length < 2) {
                throw new Error(`ANOVA requires at least 2 categories. Found ${categories.length} categories.`);
            }
            
            // Group data by category
            const groupsData = categories.map(cat => {
                return catData
                    .map((val, idx) => String(val) === cat ? contData[idx] : null)
                    .filter(val => val !== null);
            });
            
            // Perform ANOVA
            const result = anovaOneWay(groupsData);
            
            let stats = `=== ONE-WAY ANOVA ===\n\n`;
            stats += `Categorical variable: ${catVar}\n`;
            stats += `Continuous variable: ${contVar}\n`;
            stats += `Number of groups: ${categories.length}\n`;
            stats += `Total observations: ${result.totalN}\n\n`;
            
            stats += `=== GROUP STATISTICS ===\n`;
            categories.forEach((cat, i) => {
                const group = result.groupStats[i];
                if (group) {
                    stats += `Group ${i+1} (${cat}):\n`;
                    stats += `  n: ${group.n}\n`;
                    stats += `  Mean: ${group.mean.toFixed(4)}\n`;
                    stats += `  Standard Deviation: ${Math.sqrt(group.variance).toFixed(4)}\n`;
                    stats += `  Variance: ${group.variance.toFixed(4)}\n\n`;
                }
            });
            
            stats += `Overall mean: ${result.overallMean.toFixed(4)}\n\n`;
            
            stats += `=== ANOVA TABLE ===\n`;
            stats += `Source           SS          df     MS          F        p-value\n`;
            stats += `----------------------------------------------------------------\n`;
            stats += `Between groups  ${result.SSBetween.toFixed(4)}  ${result.dfBetween}    ${result.MSBetween.toFixed(4)}  ${result.F.toFixed(4)}  ${result.pValue.toFixed(6)}\n`;
            stats += `Within groups   ${result.SSWithin.toFixed(4)}   ${result.dfWithin}    ${result.MSWithin.toFixed(4)}\n`;
            stats += `Total           ${result.SSTotal.toFixed(4)}   ${result.dfTotal}\n\n`;
            
            stats += `=== EFFECT SIZE ===\n`;
            stats += `Eta squared (Î·Â²): ${result.etaSquared.toFixed(4)}\n`;
            if (result.etaSquared < 0.01) {
                stats += `Interpretation: Very small effect\n`;
            } else if (result.etaSquared < 0.06) {
                stats += `Interpretation: Small effect\n`;
            } else if (result.etaSquared < 0.14) {
                stats += `Interpretation: Medium effect\n`;
            } else {
                stats += `Interpretation: Large effect\n`;
            }
            stats += `\n`;
            
            stats += `=== HYPOTHESES ===\n`;
            stats += `Hâ‚€: Î¼â‚ = Î¼â‚‚ = ... = Î¼â‚– (all population means are equal)\n`;
            stats += `Hâ‚: At least one population mean is different\n\n`;
            
            stats += `=== INTERPRETATION ===\n`;
            if (result.pValue < 0.05) {
                stats += `Significant at Î±=0.05: REJECT Hâ‚€\n`;
                stats += `There is a significant difference between at least two group means.\n`;
                stats += `Post-hoc tests would be needed to determine which specific groups differ.\n`;
            } else {
                stats += `Not significant at Î±=0.05: FAIL TO REJECT Hâ‚€\n`;
                stats += `No significant difference between group means.\n`;
            }
            
            // Post-hoc suggestion
            if (result.pValue < 0.05 && categories.length > 2) {
                stats += `\n=== POST-HOC ANALYSIS SUGGESTION ===\n`;
                stats += `Since ANOVA is significant and there are ${categories.length} groups,\n`;
                stats += `consider performing post-hoc tests (e.g., Tukey's HSD) to identify\n`;
                stats += `which specific group pairs are significantly different.\n`;
            }
            
            return stats;
        }
        
        // Other analysis functions
        function performTwoCategoricalAnalysis(var1, var2, var1Data, var2Data) {
            const categories1 = [...new Set(var1Data.map(String))];
            const categories2 = [...new Set(var2Data.map(String))];
            
            // Create contingency table
            const contingencyTable = categories1.map(cat1 => {
                return categories2.map(cat2 => {
                    let count = 0;
                    const n = Math.min(var1Data.length, var2Data.length);
                    for (let i = 0; i < n; i++) {
                        if (String(var1Data[i]) === cat1 && String(var2Data[i]) === cat2) {
                            count++;
                        }
                    }
                    return count;
                });
            });
            
            let stats = `=== TWO CATEGORICAL VARIABLES ANALYSIS ===\n\n`;
            stats += `Variables: ${var1} and ${var2}\n`;
            stats += `Observations: ${var1Data.length}\n\n`;
            
            stats += `=== CONTINGENCY TABLE ===\n`;
            stats += `Rows: ${var1}, Columns: ${var2}\n\n`;
            
            // Add column headers
            stats += `        `;
            categories2.forEach(cat2 => {
                stats += `${cat2.padEnd(10)}`;
            });
            stats += `Total\n`;
            
            // Add table rows
            let rowTotals = [];
            let colTotals = Array(categories2.length).fill(0);
            let grandTotal = 0;
            
            categories1.forEach((cat1, i) => {
                stats += `${cat1.padEnd(8)}`;
                let rowTotal = 0;
                categories2.forEach((cat2, j) => {
                    const count = contingencyTable[i][j];
                    stats += `${count.toString().padEnd(10)}`;
                    rowTotal += count;
                    colTotals[j] += count;
                    grandTotal += count;
                });
                stats += `${rowTotal}\n`;
                rowTotals.push(rowTotal);
            });
            
            // Add column totals
            stats += `Total   `;
            categories2.forEach((cat2, j) => {
                stats += `${colTotals[j].toString().padEnd(10)}`;
            });
            stats += `${grandTotal}\n`;
            
            return stats;
        }
        
        function performChiSquareTest(var1, var2, var1Data, var2Data) {
            const stats = performTwoCategoricalAnalysis(var1, var2, var1Data, var2Data);
            return stats + `\n=== NOTE: Chi-square test would be implemented here ===\n`;
        }
        
        function performCategoricalContinuousAnalysis(catVar, contVar, catData, contData) {
            const categories = [...new Set(catData.map(String))];
            const groupedData = {};
            
            categories.forEach(cat => {
                groupedData[cat] = [];
            });
            
            const n = Math.min(catData.length, contData.length);
            for (let i = 0; i < n; i++) {
                const cat = String(catData[i]);
                if (groupedData[cat]) {
                    groupedData[cat].push(contData[i]);
                }
            }
            
            let stats = `=== CATEGORICAL vs CONTINUOUS ANALYSIS ===\n\n`;
            stats += `Categorical variable: ${catVar}\n`;
            stats += `Continuous variable: ${contVar}\n`;
            stats += `Observations: ${n}\n\n`;
            
            stats += `=== GROUP STATISTICS ===\n`;
            
            categories.forEach(cat => {
                const data = groupedData[cat];
                if (data.length > 0) {
                    const m = mean(data);
                    const med = median(data);
                    const sd = stdDev(data);
                    const min = Math.min(...data);
                    const max = Math.max(...data);
                    
                    stats += `\nGroup: ${cat}\n`;
                    stats += `  Sample size: ${data.length}\n`;
                    stats += `  Mean: ${m.toFixed(4)}\n`;
                    stats += `  Median: ${med.toFixed(4)}\n`;
                    stats += `  Standard Deviation: ${sd.toFixed(4)}\n`;
                    stats += `  Range: ${min.toFixed(4)} to ${max.toFixed(4)}\n`;
                }
            });
            
            return stats;
        }
        
        function performTwoContinuousAnalysis(var1, var2, var1Data, var2Data) {
            const n = Math.min(var1Data.length, var2Data.length);
            const corr = correlation(var1Data.slice(0, n), var2Data.slice(0, n));
            
            let stats = `=== TWO CONTINUOUS VARIABLES ANALYSIS ===\n\n`;
            stats += `Variables: ${var1} and ${var2}\n`;
            stats += `Paired observations: ${n}\n\n`;
            
            stats += `=== DESCRIPTIVE STATISTICS ===\n`;
            stats += `${var1}: Mean = ${mean(var1Data.slice(0, n)).toFixed(4)}, SD = ${stdDev(var1Data.slice(0, n)).toFixed(4)}\n`;
            stats += `${var2}: Mean = ${mean(var2Data.slice(0, n)).toFixed(4)}, SD = ${stdDev(var2Data.slice(0, n)).toFixed(4)}\n\n`;
            
            stats += `=== CORRELATION ===\n`;
            stats += `Pearson correlation coefficient (r): ${isNaN(corr) ? 'N/A' : corr.toFixed(4)}\n`;
            
            return stats;
        }
        
        function performCorrelationAnalysis(var1, var2, var1Data, var2Data) {
            const stats = performTwoContinuousAnalysis(var1, var2, var1Data, var2Data);
            return stats + `\n=== NOTE: Full correlation analysis would be implemented here ===\n`;
        }
        
        // Helper functions for UI
        function showUploadError(message) {
            uploadError.textContent = message;
            uploadError.classList.add('active');
        }
        
        function clearUploadError() {
            uploadError.textContent = '';
            uploadError.classList.remove('active');
        }
        
        function toggleHelpPopup() {
            helpPopup.classList.toggle('active');
            if (helpPopup.classList.contains('active')) {
                toggleHelp.textContent = 'Ã—';
                toggleHelp.style.backgroundColor = '#e74c3c';
            } else {
                toggleHelp.textContent = '?';
                toggleHelp.style.backgroundColor = '#4a6fa5';
            }
        }
        
        function changeHelpPage(delta) {
            const newPage = currentHelpPage + delta;
            
            if (newPage >= 1 && newPage <= 3) {
                currentHelpPage = newPage;
                showHelpPage(currentHelpPage);
            }
        }
        
        function showHelpPage(pageNum) {
            document.querySelectorAll('.help-page').forEach(page => {
                page.classList.remove('active');
            });
            
            document.getElementById(`page${pageNum}`).classList.add('active');
            currentPageSpan.textContent = pageNum;
            
            prevPageBtn.disabled = pageNum === 1;
            nextPageBtn.disabled = pageNum === 3;
        }
        
        function resetApp() {
            fileInput.value = '';
            csvData = [];
            headers = [];
            columnTypes = {};
            
            var1Select.innerHTML = '<option value="">Select a variable</option>';
            var2Select.innerHTML = '<option value="">Select a variable (optional)</option>';
            var1Select.disabled = true;
            var2Select.disabled = true;
            
            analysisTypeGroup.innerHTML = '<div class="status-message">Select variables to see analysis options</div>';
            testParams.classList.remove('active');
            analyzeBtn.disabled = true;
            
            dataPreview.style.display = 'none';
            dataLoadedMessage.classList.remove('active');
            anovaWarning.style.display = 'none';
            
            resultsContainer.innerHTML = '<div class="status-message">Configure and run an analysis to see results here.</div>';
            
            if (currentChart) {
                currentChart.destroy();
                currentChart = null;
            }
            
            clearUploadError();
        }
        
        function loadSampleData() {
            // Enhanced sample data with more categories for testing ANOVA
            const sampleCSV = `Category,Score,Group,Age,Gender,Income,Department,Experience
A,85,Control,25,Male,45000,Sales,3
B,92,Treatment,32,Female,52000,Marketing,7
A,78,Control,28,Male,48000,Sales,5
C,88,Placebo,45,Female,68000,Engineering,20
B,95,Control,36,Male,55000,Marketing,10
C,82,Treatment,29,Female,49000,Engineering,6
A,90,Placebo,41,Male,62000,Sales,15
B,87,Treatment,33,Male,51000,Marketing,8
C,91,Control,37,Female,58000,Engineering,12
A,84,Treatment,26,Female,47000,Sales,4
D,89,Control,39,Male,60000,HR,9
D,93,Treatment,31,Female,53000,HR,11
D,79,Placebo,27,Male,46000,HR,2
D,86,Control,44,Female,66000,HR,18`;
            
            // Show loading state
            resultsContainer.innerHTML = '<div class="loading">Loading sample data...</div>';
            
            Papa.parse(sampleCSV, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    csvData = results.data;
                    headers = results.meta.fields;
                    
                    determineColumnTypes();
                    updateDataPreview();
                    updateVariableSelects();
                    dataPreview.style.display = 'block';
                    analyzeBtn.disabled = false;
                    dataLoadedMessage.classList.add('active');
                    
                    dataInfo.textContent = `Loaded sample data: ${csvData.length} rows with ${headers.length} variables.`;
                    
                    // Auto-select variables for ANOVA demo
                    setTimeout(() => {
                        if (headers.length >= 2) {
                            var1Select.value = 'Group'; // Categorical with 3+ categories
                            var2Select.value = 'Score'; // Continuous
                            var1Select.dispatchEvent(new Event('change'));
                            var2Select.dispatchEvent(new Event('change'));
                        }
                    }, 500);
                }
            });
        }
        
        // Initialize
        loadSampleData();
    </script>
</body>
</html>
